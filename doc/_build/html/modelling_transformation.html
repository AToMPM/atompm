

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Modelling a Model Transformation &mdash; AToMPM 0.6 documentation</title>
    
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/mystyle.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.6',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="AToMPM 0.6 documentation" href="index.html" />
    <link rel="next" title="Executing a Model Transformation" href="executing_transformation.html" />
    <link rel="prev" title="Using a Modelling Language" href="using_language.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="executing_transformation.html" title="Executing a Model Transformation"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="using_language.html" title="Using a Modelling Language"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">AToMPM 0.6 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="modelling-a-model-transformation">
<span id="id1"></span><h1>Modelling a Model Transformation<a class="headerlink" href="#modelling-a-model-transformation" title="Permalink to this headline">¶</a></h1>
<p>A model transformation consists of a set of rules that match and rewrite parts of the model, and a schedule that governs the order in which rules are executed. In the next subsections, we explain how to create these elements. In <a class="reference internal" href="executing_transformation.html#executing-a-model-transformation"><span class="std std-ref">Executing a Model Transformation</span></a>, we explain how to execute the modelled transformation.</p>
<p>In this section, we make use of the <em>TransformationEditor</em> toolbar:</p>
<img alt="_images/transformation_editor.png" src="_images/transformation_editor.png" />
<div class="section" id="compiling-a-language-to-a-pattern-language">
<h2>Compiling a Language to a Pattern Language<a class="headerlink" href="#compiling-a-language-to-a-pattern-language" title="Permalink to this headline">¶</a></h2>
<p>A prerequisite to modelling rules is to compile the language of the models you want to transform to a pattern language. This pattern language is used in the rules you model, and is very similar to the original language. This makes modelling the patterns very intuitive (since almost the same syntax is used), while changing the language to accomodate the matching and rewriting process.</p>
<img alt="_images/compilation_toolbar.png" src="_images/compilation_toolbar.png" />
<p>To compile a language to a pattern language, press the third button on the <em>CompileMenu</em> toolbar. Navigate to the abstract syntax metamodel you want to compile:</p>
<img alt="_images/compile_pattern.png" src="_images/compile_pattern.png" />
<p>Pressing the &#8216;ok&#8217; button will create the abstract syntax metamodel <em>TrafficLight.pattern.metamodel</em> and the formalism toolbar <em>TrafficLight.defaultIcons.pattern.metamodel</em> in the <em>/Formalisms/TrafficLight</em> user folder. This formalism is used alongside <a class="reference internal" href="#the-rule-language"><span class="std std-ref">The Rule Language</span></a> to model the rules of the model transformation. The pattern language differs from the original language in three ways:</p>
<ul class="simple">
<li>Its constraints are <strong>relaxed</strong>. More precisely, abstract classes in the original language are made concrete, and minimum cardinalities are removed.</li>
<li>Elements in the language are <strong>augmented</strong> with four attributes: <em>__pLabel</em>, <em>__pMatchSubtypes</em>, <em>__pPivotIn</em>, and <em>__pPivotOut</em>. We will only use the two first ones. <em>__pLabel</em> is used to identify elements across LHS/RHS/NAC patterns, and <em>__pMatchSubtypes</em> indicates that instances of subclasses should also be matched.</li>
<li>The type of the attributes of each element is changed to <em>code</em>. This allows to model <em>constraints</em> in LHS/NAC patterns on the values of the attributes in the host model and <em>actions</em> in RHS patterns to compute the new values of the attributes after rewriting.</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Constraint and action code in patterns is written in Python!</p>
</div>
</div>
<div class="section" id="initializing-schedules-rules">
<h2>Initializing Schedules/Rules<a class="headerlink" href="#initializing-schedules-rules" title="Permalink to this headline">¶</a></h2>
<p>A formalism created with the &#8220;new formalism&#8221; button on the <em>MainMenu</em> toolbar (see <a class="reference internal" href="overview.html#overview"><span class="std std-ref">Overview</span></a>) comes initialized with two schedules: <em>OperationalSemantics/T_OperationalSemantics.model</em> and <em>TranslationalSemantics/T_TranslationalSemantics.model</em>. These can be used to model the schedule of the formalism&#8217;s operational semantics (a simulator) and translational semantics (a mapping onto a domain with known semantics), respectively.</p>
<p>If you want to initialize a new schedule, use the fourth button on the <em>TransformationEditor</em> toolbar. This will present you with a file browser, which allows you to choose a location and a name for the schedule. The schedule will automatically open in a new AToMPM instance.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A schedule&#8217;s name has to start with the T_ prefix!</p>
</div>
<p>If you want to initialize a new rule, use the fifth button on the <em>TransformationEditor</em> toolbar. This will present you with a file browser, which allows you to choose a location and a name for the rule. The rule will automatically open in a new AToMPM instance.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A rule&#8217;s name has to start with the R_ prefix!</p>
</div>
</div>
<div class="section" id="the-rule-language">
<span id="id2"></span><h2>The Rule Language<a class="headerlink" href="#the-rule-language" title="Permalink to this headline">¶</a></h2>
<p>When creating a rule, it is initialized with the three basic components of every rule: a <em>Negative Application Condition</em> (NAC), a <em>Left-Hand-Side</em> (LHS), and a <em>Right-Hand-Side</em> (RHS).</p>
<a class="reference internal image-reference" href="_images/rule_init.png"><img alt="_images/rule_init.png" src="_images/rule_init.png" style="width: 663.5px; height: 280.0px;" /></a>
<p>In general, a rule has to have exactly one LHS, exactly one RHS, and zero or more NACs. The LHS is used to <em>match a pattern</em> in the host model. It is a positive application condition: if the pattern is found in the host model, the rule can be applied. If the pattern in one of the NACs is found, however, the rule is disabled. The RHS is used to <em>rewrite the pattern</em> in the host model.</p>
<p>To model the patterns, we need to load the pattern language we compiled earlier. Press the third button on the <em>TransformationEditor</em> toolbar. Navigate to your pattern metamodel:</p>
<img alt="_images/load_pattern_metamodel.png" src="_images/load_pattern_metamodel.png" />
<p>This will load the formalism toolbar of the pattern language for use in LHS, RHS, and NAC patterns.</p>
<div class="section" id="lhs-and-nac">
<h3>LHS and NAC<a class="headerlink" href="#lhs-and-nac" title="Permalink to this headline">¶</a></h3>
<p>The LHS and NACs are so-called <em>precondition patterns</em>. When a rule is selected for execution, it will try to find a match in the host model for the LHS. If one is found, it will try to match all the NACs. If a match is found for one of them, the rule is not executed.</p>
<img alt="_images/example_LHS.png" src="_images/example_LHS.png" />
<p>In the example LHS above, we try to find the current interrupt in the interrupt list, but only if the clock has advanced to a point in time <em>after or equal to</em> the time specified in that interrupt. To do this, we model:</p>
<ul class="simple">
<li>An instance of <em>__pInterrupt</em> (with label &#8216;1&#8217;). Each attribute has to assign a boolean value to the &#8216;result&#8217; variable, indicating whether the instance can be matched based on the value of the attribute. The current value can be accessed using the <em>getAttr()</em> function. For a complete overview of functions that can be called from action and condition code in patterns, see <a class="reference internal" href="#mt-action-library"><span class="std std-ref">Action Library</span></a>. In our example, we only want to make sure the <em>current</em> attribute is <em>True</em>. We set all conditions to <em>result = True</em> (the default), except for the <em>current</em> attribute, where we require <em>result = (getAttr() == True)</em> &#8211; or, more simply, <em>result = getAttr()</em>.</li>
<li>An instance of the <em>AbstractInterrupt</em>, connected to the first interrupt. We instantiate the abstract class here, because potentially, it is the <em>end</em> of the list, and we want to make sure to match both normal interrupts and end interrupts.</li>
<li>The <em>Time</em> instance (which we know is a singleton).</li>
</ul>
<p>The condition that the clock needs to have advanced beyond the time specified in the current interrupt cannot be modelled as a condition on one single attribute, since it spans multiple instances (the <em>Time</em> instance and the first <em>Interrupt</em> instance). A precondition pattern also allows a global condition, which needs to be satisfied in order for the pattern to match. In this case, we get the current time, the event time, and compare them. Again, the resulting boolean is assigned to the variable <em>result</em>.</p>
<p>When executing the transformation, AToMPM will try to find a match for each of the pattern elements. If one is found, it will map each <em>__pLabel</em> value to a matched element:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span>
   <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">AbstractInterrupt</span> <span class="n">Instance</span><span class="o">&gt;</span>
   <span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">Interrupt</span> <span class="n">Instance</span><span class="o">&gt;</span>
   <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">Next</span> <span class="n">Instance</span><span class="o">&gt;</span>
   <span class="s1">&#39;3&#39;</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">Time</span> <span class="n">Instance</span><span class="o">&gt;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is called a binding. AToMPM will find as many matches as possible. This results in a match set.</p>
</div>
<div class="section" id="rhs">
<h3>RHS<a class="headerlink" href="#rhs" title="Permalink to this headline">¶</a></h3>
<p>The RHS is the <em>postcondition pattern</em>. It specifies how the elements matched by the LHS should be rewritten. In general:</p>
<ul class="simple">
<li>Elements in the RHS with a <em>__pLabel</em> that cannot be found in the LHS are created.</li>
<li>Elements in the LHS with a <em>__pLabel</em> that cannot be found in the RHS are deleted.</li>
<li>Elements in the RHS with a <em>__pLabel</em> that can be found in the LHS are updated according to the actions modelled in the RHS.</li>
</ul>
<img alt="_images/example_RHS.png" src="_images/example_RHS.png" />
<p>The task of the right-hand side of our rule is to change the current interrupt to the next one. The <em>result</em> attribute now should get the new value of the attribute. If nothing needs to change, one can simply write <em>result = getAttr()</em>. In this case, the <em>current</em> attribute of the first interrupt is changed to <em>False</em>, while the <em>current</em> attribute of the second interrupt is changed to <em>True</em>. The rest of the attributes remains unchanged. For a complete overview of functions that can be called from action and condition code in patterns, see <a class="reference internal" href="#mt-action-library"><span class="std std-ref">Action Library</span></a>.</p>
</div>
</div>
<div class="section" id="the-motif-scheduling-language">
<h2>The MoTif Scheduling Language<a class="headerlink" href="#the-motif-scheduling-language" title="Permalink to this headline">¶</a></h2>
<p>Rules are scheduled using a scheduling language. We use <em>MoTif</em>, which exposes a number of primitives, or <em>steps</em>. A schedule consists of a number of steps starting at the <em>Start</em> pseudostep and ending in either a <em>EndSuccess</em> or <em>EndFail</em> pseudostep. Each step is connected to two other steps with a <em>success</em> or a <em>fail</em> link. Depending on the type of step, the referenced rule(s) are executed in a particular way. The steps exposed by MoTif are:</p>
<img alt="_images/MoTif_toolbar.png" src="_images/MoTif_toolbar.png" />
<ol class="arabic simple">
<li><strong>ARule</strong>: Atomic rule. Executes the rule for one match found. If no matches are found, it fails.</li>
<li><strong>QRule</strong>: A query. Succeeds if the LHS matches and the NACs do not match. The RHS of the rule is ignored.</li>
<li>Unused.</li>
<li>Unused.</li>
<li><strong>FRule</strong>: For-all rule. Executes the rule for each match in the match set. It fails if no matches can be found.</li>
<li><strong>SRule</strong>: Sequence rule. Executes the rule until no more matches can be found. It fails if no matches can be found.</li>
<li><strong>Start</strong>: The start of the schedule. Can only appear once.</li>
<li><strong>EndSuccess</strong>: The end of the schedule (indicating success). Can occur more than once, but the schedule ends when one of them is reached.</li>
<li><strong>EndFail</strong>: The end of the schedule (indicating failure). Can occur more than once, but the schedule ends when one of them is reached.</li>
<li><strong>Sequence</strong>: Executes the referenced transformation until it fails.</li>
<li><strong>BRule</strong>: Allows for other steps to be nested. Executes (non-deterministically) one of the succeeding child steps.</li>
<li><strong>CRule</strong>: Nested transformation. The referenced transformation schedule is executed once.</li>
<li><strong>BSRule</strong>: Executes (non-deterministically) one of the succeeding child steps until none of them succeeds.</li>
<li>Unused.</li>
<li>Unused.</li>
<li>Unused.</li>
<li>Unused.</li>
</ol>
</div>
<div class="section" id="action-library">
<span id="mt-action-library"></span><h2>Action Library<a class="headerlink" href="#action-library" title="Permalink to this headline">¶</a></h2>
<div class="table-with-borders admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <em>_id</em> attribute can either be an abstract syntax identifier, or a <em>__pLabel</em> value.</p>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="24%" />
<col width="51%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">name</th>
<th class="head">parameters</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>getAttr(_attr[, _id])</td>
<td><ul class="first last simple">
<li><em>_attr</em>: string</li>
<li><em>_id</em>: string</li>
</ul>
</td>
<td>Return the value of the given attribute from the given entity, specified
via its abstract syntax identifier or __pLabel. If no such attribute exists,
the current constraint, action, mapper, or parser is immediately interrupted
and an error is presented to the user.</td>
</tr>
<tr class="row-odd"><td>hasAttr(_attr[, _id])</td>
<td><ul class="first last simple">
<li><em>_attr</em>: string</li>
<li><em>_id</em>: string</li>
</ul>
</td>
<td>Returns <em>true</em> if the given entity, specified via its abstract syntax
identifier or __pLabel, has an attribute named <em>attr</em>, <em>false</em> otherwise.</td>
</tr>
<tr class="row-even"><td>getAttrNames(_id)</td>
<td><ul class="first last simple">
<li><em>_id</em>: string</li>
</ul>
</td>
<td>Return all attribute names of the given entity, specified via its abstract
syntax identifier or __pLabel.</td>
</tr>
<tr class="row-odd"><td>getAllNodes(_fulltypes)</td>
<td><ul class="first last simple">
<li><em>_fulltypes</em>: list&lt;string&gt;</li>
</ul>
</td>
<td>Return the abstract syntax identifiers of all entities whose types are
contained within the fulltypes array. If it is omitted, return the abstract
syntax identifiers of all entities. The notion of full types is best
explained by example: the full type of a SimpleClassDiagram.Class entity is
&#8220;/Formalisms/__LanguageSyntax__/SimpleClassDiagram/SimpleClassDiagram/Class&#8221;.</td>
</tr>
<tr class="row-even"><td>getNeighbors(_dir[, _type, _id])</td>
<td><ul class="first last simple">
<li><em>_dir</em>: string</li>
<li><em>_type</em>: string</li>
<li><em>_id</em>: string</li>
</ul>
</td>
<td>Return neighbours of the given entity, specified via its abstract syntax
identifier or __pLabel. The <em>_dir</em> parameter can take on three values: &#8220;in&#8221;
implies that only inbound neighbours should be returned, &#8220;out&#8221; implies that
only outbound neighbours should be returned, &#8220;*&#8221; implies that neighbours in
either direction should be returned. Finally, the <em>_type</em> parameter can be
set to indicate that only neighbours of the given full type should be
returned. The notion of full types is best explained by example: the full
type of a SimpleClassDiagram.Class entity is
&#8220;/Formalisms/__LanguageSyntax__/SimpleClassDiagram/SimpleClassDiagram/Class&#8221;.
To match any type, use &#8220;*&#8221;.</td>
</tr>
<tr class="row-odd"><td>print(msg)</td>
<td><ul class="first last simple">
<li><em>msg</em>: string</li>
</ul>
</td>
<td>Print the given string to the console that launched the AToMPM back-end.</td>
</tr>
<tr class="row-even"><td>setAttr(_attr, _val[, _id])</td>
<td><ul class="first last simple">
<li><em>_attr</em>: string</li>
<li><em>_val</em>: any</li>
<li><em>_id</em>: string</li>
</ul>
</td>
<td>Update the given attribute of the given entity, specified via its abstract
syntax identifier, to the given value. Note that this function is only
available from within meta-modelling actions. Also, beware the fact that
calls to <em>setAttr()</em> are not treated like normal model updates (<em>i.e.</em>, they
do not trigger pre-editing constraints and post-editing actions).</td>
</tr>
<tr class="row-odd"><td>httpReq(method, host, url, data)</td>
<td><ul class="first last simple">
<li><em>method</em>: string</li>
<li><em>host</em>: string</li>
<li><em>url</em>: string</li>
<li><em>data</em>: dict</li>
</ul>
</td>
<td>Perform a synchronous HTTP request given an HTTP method (GET, PUT, POST or
DELETE), a URL and a key-value dictionary of parameters. If host is
undefined, the request is automatically routed to the AToMPM backend. This
can be useful to make use of the Remote API from within rule code.</td>
</tr>
<tr class="row-even"><td>isConnectionType(_id)</td>
<td><ul class="first last simple">
<li><em>_id</em>: string</li>
</ul>
</td>
<td>Return true if the given entity, specified via its abstract syntax identifier
or its __pLabel, is a connection type, false otherwise.</td>
</tr>
<tr class="row-odd"><td>session_get(_key)
session_put(_key, _val)</td>
<td><ul class="first last simple">
<li><em>_key</em>: string</li>
<li><em>_val</em>: any</li>
</ul>
</td>
<td>The <em>Transformation Session</em> is a sandbox of sorts that enables miscellaneous
user data to be easily accessed and stored across several rule and
transformation executions. It is only ever cleared when a transformation
is (re-)loaded. These methods respectively enable retrieving and
setting/updating a stored value.</td>
</tr>
<tr class="row-even"><td>sys_call(_args)</td>
<td><ul class="first last simple">
<li><em>_args</em>: list&lt;string&gt;</li>
</ul>
</td>
<td>Perform a system call on the machine hosting the AToMPM back-end. An example
value for the _args parameter is [&#8220;ls&#8221;, &#8220;-l&#8221;].</td>
</tr>
<tr class="row-odd"><td>sys_mkdir(_path)</td>
<td><ul class="first last simple">
<li><em>_path</em>: string</li>
</ul>
</td>
<td>Create the given directory (or directories).</td>
</tr>
<tr class="row-even"><td>sys_readf(_path)</td>
<td><ul class="first last simple">
<li><em>_path</em>: string</li>
</ul>
</td>
<td>Return the contents of the given file.</td>
</tr>
<tr class="row-odd"><td>sys_writef(_path, _content, [_append])</td>
<td><ul class="first last simple">
<li><em>_path</em>: string</li>
<li><em>_content</em>: string</li>
<li><em>_append</em>: boolean</li>
</ul>
</td>
<td>Write content to the given file, overwriting its contents if the append
attribute is set to <em>false</em>.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="trafficlight-example">
<h2>TrafficLight Example<a class="headerlink" href="#trafficlight-example" title="Permalink to this headline">¶</a></h2>
<p>As an example, let&#8217;s model the operational semantics of the <em>TrafficLight</em> language. The requirements are:</p>
<ul>
<li><p class="first">First, the global time is initialized to 0. Then, the current state is made to refer to the start state of the model. Then, the simulation continues until no more state transitions are possible.</p>
</li>
<li><dl class="first docutils">
<dt>A state transition T from the current state C to a new state (possibly the same) N occurs:</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>If there is a timed state transition T from the current state C to a new state (possibly the same) N, this transition will be taken if the global time + the time delay of the transition is strictly smaller than the time of the earliest interrupt notice in the external interrupt list (if any is present: the interrupt list may be empty). Combined with the description of the interrupt transition below, the strictly smaller required will ensure that an external interrupt takes priority over a timed transition, if they happen to occur at exactly the same time (a so-called event collision). The effects of this state transition are:</dt>
<dd><ol class="first last arabic simple">
<li>The global time is updated to the global time + the time delay of the transition</li>
<li>The current state is updated to state N</li>
</ol>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>If there is an interrupt transition from the current state C for which the interrupt name is equal to the interrupt name in the earliest interrupt notice in the external interrupt list. The effects of this state transition are:</dt>
<dd><ol class="first last arabic simple">
<li>The global time is updated to the time in the interrupt notice</li>
<li>The current state is updated to state N</li>
<li>The interrupt notice is removed from the interrupt list</li>
</ol>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
<img alt="_images/example_schedule.png" src="_images/example_schedule.png" />
<p>The first step in the initializes the simulation: it looks for the initial state and makes it the current state.
Then, it tries executing a timed transition. If it fails, it tries executing an interrupt.
At the end, the next interrupt is chosen if the time has advanced sufficiently.</p>
<img alt="_images/example_rules.png" src="_images/example_rules.png" />
<p>The rules are shown above. Most of them do not change the structure of the model, and most of the computation is done in the actions and constraints of the patterns.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Modelling a Model Transformation</a><ul>
<li><a class="reference internal" href="#compiling-a-language-to-a-pattern-language">Compiling a Language to a Pattern Language</a></li>
<li><a class="reference internal" href="#initializing-schedules-rules">Initializing Schedules/Rules</a></li>
<li><a class="reference internal" href="#the-rule-language">The Rule Language</a><ul>
<li><a class="reference internal" href="#lhs-and-nac">LHS and NAC</a></li>
<li><a class="reference internal" href="#rhs">RHS</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-motif-scheduling-language">The MoTif Scheduling Language</a></li>
<li><a class="reference internal" href="#action-library">Action Library</a></li>
<li><a class="reference internal" href="#trafficlight-example">TrafficLight Example</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="using_language.html"
                        title="previous chapter">Using a Modelling Language</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="executing_transformation.html"
                        title="next chapter">Executing a Model Transformation</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/modelling_transformation.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="executing_transformation.html" title="Executing a Model Transformation"
             >next</a> |</li>
        <li class="right" >
          <a href="using_language.html" title="Using a Modelling Language"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">AToMPM 0.6 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2016, Raphael Mannadiar, Simon Van Mierlo, Huseyin Ergin, Conner Hansen, Eugene Syriani, Jonathan Corley.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.5.
    </div>
  </body>
</html>